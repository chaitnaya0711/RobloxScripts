-- Services
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

-- Variables
local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local mouse = localPlayer:GetMouse()

-- Tables to hold checkpoints, lines, and tracked players
local checkpoints = {}
local lines = {}
local trackedPlayers = {}
local announcementInProgress = false -- To prevent multiple alerts from showing at the same time
local MAX_TRACKED_PLAYERS = 3 -- Maximum number of players that can be tracked

-- Create the ScreenGui
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "MapMeasuringGUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = localPlayer:WaitForChild("PlayerGui")

-- Function to create rounded corners
local function makeRounded(instance, radius)
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(0, radius)
    uiCorner.Parent = instance
end

-- Function to get dynamic size based on screen size
local function getDynamicSize()
    local camera = Workspace.CurrentCamera
    if not camera then return UDim2.new(0, 600, 0, 800) end -- Fallback size
    local viewportSize = camera.ViewportSize
    local minDimension = math.min(viewportSize.X, viewportSize.Y)
    return UDim2.new(0, minDimension * 0.6, 0, minDimension * 0.8)
end

-- Create the main frame with a sleek dark theme
local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = getDynamicSize()
MainFrame.Position = UDim2.new(0.5, 0, 1.5, 0) -- Start off-screen
MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
MainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
MainFrame.BorderSizePixel = 0
MainFrame.ClipsDescendants = true
MainFrame.Visible = false
MainFrame.Parent = ScreenGui
makeRounded(MainFrame, 20)

-- Create the title bar
local TitleBar = Instance.new("Frame")
TitleBar.Name = "TitleBar"
TitleBar.Size = UDim2.new(1, 0, 0, 50)
TitleBar.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
TitleBar.BorderSizePixel = 0
TitleBar.Parent = MainFrame
makeRounded(TitleBar, 10)

-- Title label
local TitleLabel = Instance.new("TextLabel")
TitleLabel.Name = "TitleLabel"
TitleLabel.Size = UDim2.new(1, 0, 1, 0)
TitleLabel.BackgroundTransparency = 1
TitleLabel.Text = "Map Measuring Tool"
TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TitleLabel.Font = Enum.Font.GothamBold
TitleLabel.TextSize = 20
TitleLabel.Parent = TitleBar

-- Create the close button
local CloseButton = Instance.new("TextButton")
CloseButton.Name = "CloseButton"
CloseButton.Size = UDim2.new(0, 30, 0, 30)
CloseButton.Position = UDim2.new(1, -40, 0.5, 0)
CloseButton.AnchorPoint = Vector2.new(0.5, 0.5)
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
CloseButton.BorderSizePixel = 0
CloseButton.Parent = TitleBar
makeRounded(CloseButton, 10)

-- Create the ScrollingFrame for buttons
local ScrollFrame = Instance.new("ScrollingFrame")
ScrollFrame.Name = "ScrollFrame"
ScrollFrame.Size = UDim2.new(0.95, 0, 0.85, -60) -- Adjusted size to fit within MainFrame
ScrollFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
ScrollFrame.AnchorPoint = Vector2.new(0.5, 0.5)
ScrollFrame.BackgroundTransparency = 1
ScrollFrame.ScrollBarThickness = 6
ScrollFrame.CanvasSize = UDim2.new(0, 0, 5, 0) -- Increased to allow scrolling
ScrollFrame.Parent = MainFrame

-- UIListLayout for organizing buttons
local UIListLayout = Instance.new("UIListLayout")
UIListLayout.Parent = ScrollFrame
UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
UIListLayout.Padding = UDim.new(0, 10)

-- Function to create buttons
local function createButton(name, text, backgroundColor, layoutOrder)
    local button = Instance.new("TextButton")
    button.Name = name
    button.Size = UDim2.new(1, 0, 0, 50)
    button.Text = text
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.Font = Enum.Font.Gotham
    button.TextSize = 16
    button.BackgroundColor3 = backgroundColor
    button.BorderSizePixel = 0
    button.LayoutOrder = layoutOrder
    button.Parent = ScrollFrame
    makeRounded(button, 10)
    return button
end

-- Create all buttons
local AddCheckpointButton = createButton("AddCheckpointButton", "Add Checkpoint", Color3.fromRGB(52, 152, 219), 1)
local RemoveCheckpointButton = createButton("RemoveCheckpointButton", "Remove All Checkpoints", Color3.fromRGB(231, 76, 60), 2)
local ShowTotalDistanceButton = createButton("ShowTotalDistanceButton", "Show Total Distance", Color3.fromRGB(52, 152, 219), 3)
local ShowMapSizeButton = createButton("ShowMapSizeButton", "Show Map Size", Color3.fromRGB(52, 152, 219), 4)
local NearestPlayerButton = createButton("NearestPlayerButton", "Show Nearest Player", Color3.fromRGB(46, 204, 113), 5)
local FurthestPlayerButton = createButton("FurthestPlayerButton", "Show Furthest Player", Color3.fromRGB(155, 89, 182), 6)

-- Create the toggle button
local ToggleButton = Instance.new("TextButton")
ToggleButton.Name = "ToggleButton"
ToggleButton.Size = UDim2.new(0, 150, 0, 50)
ToggleButton.Position = UDim2.new(0.5, 0, 0.95, 0)
ToggleButton.AnchorPoint = Vector2.new(0.5, 0.5)
ToggleButton.Text = "Toggle GUI"
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
ToggleButton.BorderSizePixel = 0
ToggleButton.Parent = ScreenGui
makeRounded(ToggleButton, 10)

-- Function to show announcements with better error handling
local function showAnnouncement(message)
    if announcementInProgress then return end -- Prevent multiple alerts
    announcementInProgress = true

    local AnnouncementFrame = Instance.new("Frame")
    AnnouncementFrame.Size = UDim2.new(0, 300, 0, 100) -- Increased height for multi-line
    AnnouncementFrame.Position = UDim2.new(0.5, 0, 0.1, 0)
    AnnouncementFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    AnnouncementFrame.BackgroundColor3 = Color3.fromRGB(52, 152, 219)
    AnnouncementFrame.BorderSizePixel = 0
    AnnouncementFrame.Parent = ScreenGui
    makeRounded(AnnouncementFrame, 10)

    local AnnouncementLabel = Instance.new("TextLabel")
    AnnouncementLabel.Size = UDim2.new(1, 0, 1, 0)
    AnnouncementLabel.BackgroundTransparency = 1
    AnnouncementLabel.Text = message
    AnnouncementLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    AnnouncementLabel.Font = Enum.Font.GothamBold
    AnnouncementLabel.TextSize = 16
    AnnouncementLabel.TextWrapped = true
    AnnouncementLabel.Parent = AnnouncementFrame

    -- Tween the frame to appear
    local tweenIn = TweenService:Create(AnnouncementFrame, TweenInfo.new(0.5, Enum.EasingStyle.Sine), {Position = UDim2.new(0.5, 0, 0.2, 0), BackgroundTransparency = 0})
    tweenIn:Play()
    tweenIn.Completed:Wait()
    wait(2)
    -- Tween the frame to disappear
    local tweenOut = TweenService:Create(AnnouncementFrame, TweenInfo.new(0.5, Enum.EasingStyle.Sine), {Position = UDim2.new(0.5, 0, -0.5, 0), BackgroundTransparency = 1})
    tweenOut:Play()
    tweenOut.Completed:Wait()
    AnnouncementFrame:Destroy()

    announcementInProgress = false
end

-- Function to create a line label showing distance
local function createLineLabel(line, distance)
    local BillboardGui = Instance.new("BillboardGui")
    BillboardGui.Size = UDim2.new(0, 100, 0, 50)
    BillboardGui.StudsOffset = Vector3.new(0, 3, 0)
    BillboardGui.Adornee = line
    BillboardGui.AlwaysOnTop = true
    BillboardGui.Parent = line

    local DistanceLabel = Instance.new("TextLabel")
    DistanceLabel.Size = UDim2.new(1, 0, 1, 0)
    DistanceLabel.BackgroundTransparency = 1
    DistanceLabel.Text = tostring(math.floor(distance)) .. " studs"
    DistanceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    DistanceLabel.Font = Enum.Font.Gotham
    DistanceLabel.TextSize = 14
    DistanceLabel.TextWrapped = true
    DistanceLabel.Parent = BillboardGui
end

-- Function to draw a glowing line between two positions
local function drawGlowingLine(startPos, endPos)
    local line = Instance.new("Part")
    line.Size = Vector3.new(0.2, 0.2, (startPos - endPos).Magnitude)
    line.CFrame = CFrame.new(startPos, endPos) * CFrame.new(0, 0, -line.Size.Z / 2)
    line.Anchored = true
    line.CanCollide = false
    line.Color = Color3.fromRGB(255, 255, 0) -- Yellow color
    line.Material = Enum.Material.Neon -- Make the line glow
    line.Name = "GlowingLine"
    line.Parent = Workspace

    -- Add line length label
    local distance = (startPos - endPos).Magnitude
    createLineLabel(line, distance)

    table.insert(lines, line)
end

-- Function to add a checkpoint
local function addCheckpoint()
    local character = localPlayer.Character
    if not character or not character.PrimaryPart then
        showAnnouncement("Character not loaded!")
        return
    end

    local checkpoint = Instance.new("Part")
    checkpoint.Size = Vector3.new(1, 1, 1)
    checkpoint.CFrame = character.PrimaryPart.CFrame
    checkpoint.Anchored = true
    checkpoint.CanCollide = false
    checkpoint.Color = Color3.fromRGB(52, 152, 219)
    checkpoint.Material = Enum.Material.Neon
    checkpoint.Name = "Checkpoint"
    checkpoint.Parent = Workspace
    table.insert(checkpoints, checkpoint)

    -- Draw line from the last checkpoint to the new one
    if #checkpoints > 1 then
        local lastCheckpoint = checkpoints[#checkpoints - 1]
        drawGlowingLine(lastCheckpoint.Position, checkpoint.Position)
    end

    showAnnouncement("Checkpoint added!")
end

-- Function to remove all checkpoints and lines
local function removeAllCheckpoints()
    for _, checkpoint in pairs(checkpoints) do
        checkpoint:Destroy()
    end
    checkpoints = {}

    for _, line in pairs(lines) do
        line:Destroy()
    end
    lines = {}

    showAnnouncement("All checkpoints removed!")
end

-- Function to calculate the actual map size based on all BasePart objects in Workspace
local function calculateActualMapSize()
    local minX, minY, minZ = math.huge, math.huge, math.huge
    local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge

    for _, part in ipairs(Workspace:GetDescendants()) do
        if part:IsA("BasePart") then
            local pos = part.Position
            local size = part.Size / 2 -- Accounts for half of the size of each part

            -- Update min values
            minX = math.min(minX, pos.X - size.X)
            minY = math.min(minY, pos.Y - size.Y)
            minZ = math.min(minZ, pos.Z - size.Z)

            -- Update max values
            maxX = math.max(maxX, pos.X + size.X)
            maxY = math.max(maxY, pos.Y + size.Y)
            maxZ = math.max(maxZ, pos.Z + size.Z)
        end
    end

    -- Check if any parts were found
    if minX == math.huge then
        showAnnouncement("No BasePart objects found in the Workspace!")
        return
    end

    -- Calculate map size
    local size = Vector3.new(maxX - minX, maxY - minY, maxZ - minZ)
    local sizeText = string.format("Map Size:\nX: %.2f studs\nY: %.2f studs\nZ: %.2f studs", size.X, size.Y, size.Z)
    showAnnouncement(sizeText)
end

-- Function to calculate the total distance between checkpoints
local function calculateTotalDistance()
    if #checkpoints < 2 then
        showAnnouncement("Not enough checkpoints to calculate total distance!")
        return
    end

    local totalDistance = 0
    for i = 2, #checkpoints do
        totalDistance = totalDistance + (checkpoints[i].Position - checkpoints[i - 1].Position).Magnitude
    end
    showAnnouncement("Total map distance: " .. math.floor(totalDistance) .. " studs")
end

-- Function to find the nearest player
local function findNearestPlayer()
    if not character or not character.PrimaryPart then
        showAnnouncement("Character not loaded!")
        return
    end

    local nearestPlayer = nil
    local shortestDistance = math.huge

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character.PrimaryPart then
            local distance = (character.PrimaryPart.Position - player.Character.PrimaryPart.Position).Magnitude
            if distance < shortestDistance then
                shortestDistance = distance
                nearestPlayer = player
            end
        end
    end

    if nearestPlayer then
        showAnnouncement("Nearest Player: " .. nearestPlayer.Name .. " (" .. math.floor(shortestDistance) .. " studs)")
    else
        showAnnouncement("No other players found!")
    end
end

-- Function to find the furthest player
local function findFurthestPlayer()
    if not character or not character.PrimaryPart then
        showAnnouncement("Character not loaded!")
        return
    end

    local furthestPlayer = nil
    local longestDistance = 0

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character.PrimaryPart then
            local distance = (character.PrimaryPart.Position - player.Character.PrimaryPart.Position).Magnitude
            if distance > longestDistance then
                longestDistance = distance
                furthestPlayer = player
            end
        end
    end

    if furthestPlayer then
        showAnnouncement("Furthest Player: " .. furthestPlayer.Name .. " (" .. math.floor(longestDistance) .. " studs)")
    else
        showAnnouncement("No other players found!")
    end
end

-- Function to create a dynamic line between two players with distance label
local function createDynamicLineBetweenPlayers(playerA, playerB, color)
    -- Ensure both players have characters and HumanoidRootPart
    if not playerA.Character or not playerA.Character:FindFirstChild("HumanoidRootPart") then return end
    if not playerB.Character or not playerB.Character:FindFirstChild("HumanoidRootPart") then return end

    local line = Instance.new("Part")
    line.Size = Vector3.new(0.2, 0.2, (playerA.Character.HumanoidRootPart.Position - playerB.Character.HumanoidRootPart.Position).Magnitude)
    line.CFrame = CFrame.new(playerA.Character.HumanoidRootPart.Position, playerB.Character.HumanoidRootPart.Position) * CFrame.new(0, 0, -line.Size.Z / 2)
    line.Anchored = true
    line.CanCollide = false
    line.Color = color or Color3.fromRGB(255, 0, 0) -- Default red color
    line.Material = Enum.Material.Neon -- Make the line glow
    line.Name = "PlayerLine_" .. playerA.Name .. "_" .. playerB.Name
    line.Parent = Workspace

    -- Add distance label
    local distance = (playerA.Character.HumanoidRootPart.Position - playerB.Character.HumanoidRootPart.Position).Magnitude
    createLineLabel(line, distance)

    -- Update the line every frame
    local connection
    connection = RunService.RenderStepped:Connect(function()
        if not line or not line.Parent then
            connection:Disconnect()
            return
        end
        if not playerA.Character or not playerA.Character:FindFirstChild("HumanoidRootPart") or
           not playerB.Character or not playerB.Character:FindFirstChild("HumanoidRootPart") then
            line:Destroy()
            connection:Disconnect()
            return
        end

        local newStart = playerA.Character.HumanoidRootPart.Position
        local newEnd = playerB.Character.HumanoidRootPart.Position
        line.Size = Vector3.new(0.2, 0.2, (newStart - newEnd).Magnitude)
        line.CFrame = CFrame.new(newStart, newEnd) * CFrame.new(0, 0, -line.Size.Z / 2)

        -- Update distance label
        local distanceLabel = line:FindFirstChildWhichIsA("BillboardGui"):FindFirstChildWhichIsA("TextLabel")
        if distanceLabel then
            distanceLabel.Text = tostring(math.floor((newStart - newEnd).Magnitude)) .. " studs"
        end
    end)

    return line
end

-- Function to handle player tracking
-- Function to handle player tracking
local function trackPlayer(player)
    if not player or not player:IsA("Player") then return end

    -- Check how many players are currently tracked
    local currentTrackedCount = 0
    for _ in pairs(trackedPlayers) do
        currentTrackedCount = currentTrackedCount + 1
    end

    -- Limit to 2 players only
    if currentTrackedCount >= 2 then
        showAnnouncement("You can only track 2 players at once!")
        return
    end

    if trackedPlayers[player] then
        -- Player is already being tracked; untrack them
        if trackedPlayers[player].Tracker then
            trackedPlayers[player].Tracker:Destroy()
        end
        -- Remove all lines associated with this player
        for otherPlayer, data in pairs(trackedPlayers) do
            if otherPlayer ~= player then
                for i, line in ipairs(data.Lines) do
                    if line.Name == "PlayerLine_" .. player.Name .. "_" .. otherPlayer.Name or
                       line.Name == "PlayerLine_" .. otherPlayer.Name .. "_" .. player.Name then
                        line:Destroy()
                        table.remove(data.Lines, i)
                        break
                    end
                end
            end
        end
        trackedPlayers[player] = nil
        showAnnouncement("Stopped tracking " .. player.Name)
    else
        -- Check if maximum tracked players reached
        if #trackedPlayers >= MAX_TRACKED_PLAYERS or currentTrackedCount >= 2 then
            showAnnouncement("Maximum of 2 players can be tracked at once!")
            return
        end

        -- Start tracking the player
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            -- Create a BillboardGui tracker
            local tracker = Instance.new("BillboardGui")
            tracker.Size = UDim2.new(0, 20, 0, 20)
            tracker.StudsOffset = Vector3.new(0, 3, 0)
            tracker.AlwaysOnTop = true
            tracker.Name = "Tracker"
            tracker.Parent = player.Character:FindFirstChild("HumanoidRootPart")

            local trackerCircle = Instance.new("Frame")
            trackerCircle.Size = UDim2.new(1, 0, 1, 0)
            trackerCircle.Position = UDim2.new(0, 0, 0, 0)
            trackerCircle.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
            trackerCircle.BackgroundTransparency = 0.5
            trackerCircle.BorderSizePixel = 0
            trackerCircle.AnchorPoint = Vector2.new(0.5, 0.5)
            trackerCircle.Parent = tracker

            -- Initialize lines table for this player
            trackedPlayers[player] = {Tracker = tracker, Lines = {}}

            -- Create lines between this player and all other tracked players
            for otherPlayer, data in pairs(trackedPlayers) do
                if otherPlayer ~= player then
                    local line = createDynamicLineBetweenPlayers(player, otherPlayer, Color3.fromRGB(255, 0, 0))
                    table.insert(trackedPlayers[player].Lines, line)
                    table.insert(data.Lines, line) -- Also add to the other player's lines
                end
            end

            showAnnouncement("Started tracking " .. player.Name)
        else
            showAnnouncement("Player's character not fully loaded!")
        end
    end
end


-- Function to handle player clicks (supports both mouse and touch inputs)
local function handlePlayerClick(target)
    if target then
        -- Find the player associated with the target
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                if target:IsDescendantOf(player.Character) then
                    trackPlayer(player)
                    break
                end
            end
        end
    end
end

-- Detect mouse clicks
mouse.Button1Down:Connect(function()
    local target = mouse.Target
    handlePlayerClick(target)
end)

-- Detect touch inputs
UserInputService.TouchTap:Connect(function(touches, gameProcessed)
    if gameProcessed then return end
    for _, touch in ipairs(touches) do
        local target = touch.Target
        handlePlayerClick(target)
    end
end)

-- Function to handle players leaving to remove trackers
local function onPlayerRemoving(player)
    if trackedPlayers[player] then
        if trackedPlayers[player].Tracker then
            trackedPlayers[player].Tracker:Destroy()
        end
        -- Remove all lines associated with this player
        for otherPlayer, data in pairs(trackedPlayers) do
            if otherPlayer ~= player then
                for i, line in ipairs(data.Lines) do
                    if line.Name == "PlayerLine_" .. player.Name .. "_" .. otherPlayer.Name or
                       line.Name == "PlayerLine_" .. otherPlayer.Name .. "_" .. player.Name then
                        line:Destroy()
                        table.remove(data.Lines, i)
                        break
                    end
                end
            end
        end
        trackedPlayers[player] = nil
        showAnnouncement("Stopped tracking " .. player.Name)
    end
end

-- Function to handle player respawning to reattach trackers
local function onCharacterAdded(player, newCharacter)
    if trackedPlayers[player] then
        if newCharacter and newCharacter:FindFirstChild("HumanoidRootPart") then
            -- Reattach the tracker to the new character
            local tracker = trackedPlayers[player].Tracker
            tracker.Parent = newCharacter:FindFirstChild("HumanoidRootPart")

            -- Recreate lines between this player and all other tracked players
            for otherPlayer, data in pairs(trackedPlayers) do
                if otherPlayer ~= player then
                    local line = createDynamicLineBetweenPlayers(player, otherPlayer, Color3.fromRGB(255, 0, 0))
                    table.insert(trackedPlayers[player].Lines, line)
                    table.insert(data.Lines, line) -- Also add to the other player's lines
                end
            end
        end
    end
end

-- Connect player removing and character added events
Players.PlayerRemoving:Connect(onPlayerRemoving)
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(char)
        onCharacterAdded(player, char)
    end)
end)

-- Button functionalities
AddCheckpointButton.MouseButton1Click:Connect(addCheckpoint)
RemoveCheckpointButton.MouseButton1Click:Connect(removeAllCheckpoints)
ShowTotalDistanceButton.MouseButton1Click:Connect(calculateTotalDistance)
ShowMapSizeButton.MouseButton1Click:Connect(calculateActualMapSize)
NearestPlayerButton.MouseButton1Click:Connect(findNearestPlayer)
FurthestPlayerButton.MouseButton1Click:Connect(findFurthestPlayer)

-- Function to toggle GUI visibility with animation
local guiVisible = false
local function toggleGUI()
    guiVisible = not guiVisible
    if guiVisible then
        MainFrame.Visible = true
        -- Animate the frame sliding in
        MainFrame:TweenPosition(UDim2.new(0.5, 0, 0.5, 0), "Out", "Sine", 0.5, true)
    else
        -- Animate the frame sliding out
        MainFrame:TweenPosition(UDim2.new(0.5, 0, 1.5, 0), "In", "Sine", 0.5, true)
        wait(0.5)
        MainFrame.Visible = false
    end
end

ToggleButton.MouseButton1Click:Connect(toggleGUI)
CloseButton.MouseButton1Click:Connect(toggleGUI)

-- Update the size dynamically when the screen size changes
RunService.RenderStepped:Connect(function()
    MainFrame.Size = getDynamicSize()
end)
local function calculateActualMapSize()
local minX, minY, minZ = math.huge, math.huge, math.huge
local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge

for _, part in ipairs(Workspace:GetDescendants()) do
if part:IsA("BasePart") then
local pos = part.Position
local size = part.Size / 2 -- Accounts for half of the size of each part

-- Update min values
minX = math.min(minX, pos.X - size.X)
minY = math.min(minY, pos.Y - size.Y)
minZ = math.min(minZ, pos.Z - size.Z)

-- Update max values
maxX = math.max(maxX, pos.X + size.X)
maxY = math.max(maxY, pos.Y + size.Y)
maxZ = math.max(maxZ, pos.Z + size.Z)
end
end

-- Check if any parts were found
if minX == math.huge then
showAnnouncement("No BasePart objects found in the Workspace!")
return
end

-- Calculate map size
local size = Vector3.new(maxX - minX, maxY - minY, maxZ - minZ)
local sizeText = string.format("Map Size:\nX: %.2f studs\nY: %.2f studs\nZ: %.2f studs", size.X, size.Y, size.Z)
showAnnouncement(sizeText)
end